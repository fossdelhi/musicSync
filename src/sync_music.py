#!/usr/bin/env python3
import click
import subprocess
import os
import json
import dropbox
import requests


def gen_index(dirs):
    """
    This function calls bash script to generates file "Index" having address of
    all the songs from the given directory needed to be sync.

    arg dir: tuple of directories, from which songs need to by sync.

    Return False: if directory given is empty string.
    Return False: if shell script returns with exit status 1, that is when
                  shell script couldn't find the required directory.
    Return True: if Index is successfully generated by shell scripts.
    """

    if dirs == ('',):
        print("\nNull directory!")
        return False

    # To call shell script with given directories from subprocess.call(),
    # making this command "./generate_index.sh dir1 dir2" as a list.
    script_path = os.path.expanduser('~/.sync-music/scripts/generate_index.sh')
    call_script = list(dirs)
    call_script.insert(0, script_path)
    # If call_script returns with exit status 1 for "directory not found".
    if subprocess.call(call_script) in (0, 3):
        return True
    else:
        return False


def update_config(config,
                  user_file='~/.sync-music/config/keys.json'):
    """
    This function updates user given congfigurations in keys.json. For
    example API key.

    arg1 config: tuple consist of "field of configuration" and its "value".
    arg2 user_file: path to configuration file. Default path is setup by
                      executing "setup.sh"

    Return Flase: if "field of configuration" is not valid.
    Return True: if keys.json is found and configurations are updated.
    """

    if config[0] != 'dropbox.key':
        print("\nCouldn't recognize \"%s\" option. See: sync-music --help" %
              config[0])
        return False

    else:
        user_file = os.path.expanduser(user_file)
        try:
            if not os.path.isfile(user_file):
                raise AttributeError
            with open(user_file, mode='w+') as f:
                json.dump(dict({config}), f)

        except AttributeError:
            print("\nkeys.json is unavailable.")
            return False
        return True


def get_config(user_file='~/.sync-music/config/keys.json'):
    """
    This function brings the configration from keys.json. And if
    configurations are not present, then it also give a user friendly message
    to first update their configurations and then try again.

    arg1 user_file: path to configuration file. Default path is setup by
                      executing "setup.sh".

    Return False: If either keys.json is empty or not found.
    Return API key: If configurations are successfully read from the file.
    """

    user_file = os.path.expanduser(user_file)
    try:
        if os.path.isfile(user_file) is False:
            raise AttributeError
        with open(user_file, mode='r') as f:
            keys = json.loads(f.read())
            if os.stat(user_file).st_size != 0 and keys['dropbox.key'] != '':
                return keys['dropbox.key']
            else:
                print("\nPlease config sync-music with dropbox API_token.\n"
                      "See: sync-music --help")
                return False
    except AttributeError:
        print("\nkeys.json is unavailable.")
        return False


def upload_dbx():
    """
    This function upload song, whose complete path is available in the file
    "added.tmp".

    Returns True: if songs get uploaded successfully.
    Returns False: if uploading encounters any internet or Auth issues.
    """

    app_token = get_config()

    # Checking if access token is not added
    if app_token is False:
        return False

    # Creating a Dropbox object to make requests to the API.
    dbx = dropbox.Dropbox(app_token)

    # Checking token's validity.
    try:
        dbx.users_get_current_account()
    except dropbox.exceptions.AuthError:
        print("ERROR: Invalid access token. Please add correct API token.")
        return False
    except requests.exceptions.ConnectionError:
        print("Unknown Error: Check your internet connection...")
        return False

    # added.tmp is the file having paths of newly added songs to be uploaded.
    songs_file = os.path.expanduser('~/.sync-music/tmpfiles/added.tmp')
    Index_file = os.path.expanduser('~/.sync-music/tmpfiles/Index')

    with open(songs_file, 'r') as f:
        for song in f:
            print(song)
            song = song.rstrip('\n')
            # to fetch just the song name from complete path.
            song_name = song.split('/')
            song_name = song_name[-1]
            try:
                with open(song, 'rb') as mp3file:
                    dbx.files_upload(bytes(mp3file.read()), '/'+song_name)
                with open(Index_file, 'a') as index:
                    index.write(song)
                    index.write('\n')
            except dropbox.exceptions.AuthError:
                print("ERROR: While uploading the song.")
                return False
            except requests.exceptions.ConnectionError:
                print("Unknown Error: Check your internet connection and"
                      " available memory space in dropbox...")
                return False

    return True


@click.command()
@click.argument('dirs', nargs=-1, required=False)
@click.option('--config',  nargs=2, type=str,
              help="To set configurations e.i:\n"
              "--config dropbox.key <API_key>")
def main(dirs, config):

    if config and update_config(config):
        print("Configured successfully.")

    elif dirs and gen_index(dirs):
        ch = ''
        while ch not in ['y', 'Y', 'n', 'N']:
            ch = input("\nWould you like to upload these songs on"
                       "dropbox (y/n)?: ")
            if ch == 'y' or ch == 'Y':
                if upload_dbx():
                    print("\nSongs uploaded successfully.")
                    exit(0)
            elif ch == 'n' or ch == 'N':
                exit(0)
            else:
                print("\nIncorrect input!")
    else:
        exit(1)


if __name__ == '__main__':
    main()
